// electron-main.js (DEV-ONLY, non-packaged)
// Runs in Electron's MAIN process (separate from the Vue/Quasar renderer).
// Responsibilities:
//   • Create/manage the BrowserWindow (the small tray/popup UI)
//   • Manage tray icon + shortcuts
//   • Expose a few IPC endpoints used by the renderer:
//       - dict:lookup        → Jisho lookup (HTTP fetch)
//       - ankiconnect:invoke → AnkiConnect bridge (HTTP POST to 127.0.0.1:8765)
//       - morph:tokenize     → Japanese tokenization (kuromoji)
//
// Where logs appear:
//  - Anything with console.log in THIS FILE = Electron main process logs (in the terminal)
//  - Renderer console.log = DevTools console of the BrowserWindow

import { app, BrowserWindow, Tray, Menu, nativeImage, globalShortcut, screen, ipcMain } from 'electron';

import path from 'node:path';
import os from 'node:os';
import { fileURLToPath } from 'node:url';
import http from 'node:http';

import kuromoji from 'kuromoji';
import log from 'electron-log';

const log = (...args) => console.log('[main]', ...args);

// Electron can be ESM; emulate __dirname safely for resolving paths.
const currentDir = fileURLToPath(new URL('.', import.meta.url));

// Globals for window/tray references.
let mainWindow = null
let tray = null

// We expect kuromoji dict here:
// `project-root/node_modules/kuromoji/dict`
function resolveKuromojiDicPathDev() {
  const dicPath = path.join(process.cwd(), 'node_modules', 'kuromoji', 'dict');
  log('Kuromoji dicPath (dev) ->', dicPath);
  return dicPath;
}

// ------------------------------------------------------------------
// Kuromoji: lazy-build a single tokenizer (dev-only)
// ------------------------------------------------------------------
let tokenizerPromise;

function getTokenizer() {
  if (!tokenizerPromise) {
    const dicPath = path.join(process.cwd(), 'node_modules/kuromoji/dict'); // or packaged path
    tokenizerPromise = new Promise((res, rej) => {
      kuromoji.builder({ dicPath }).build((err, t) => err ? rej(err) : res(t));
    });
  }
  return tokenizerPromise;
}
// --- Small helper --------------------------------------------------
const platform = process.platform || os.platform();

// Create the frameless window that behaves like a popover.
async function createWindow () {
  mainWindow = new BrowserWindow({
    width: 400,
    height: 300,
    show: false,               
    frame: false, // no titlebar 
    resizable: false,
    alwaysOnTop: true,
    skipTaskbar: true,
    transparent: true,         
    webPreferences: {
      devTools: true,
      // Isolate main & renderer for security.
      contextIsolation: true,
      // Load the preload script generated by Quasar.
      // Quasar/Electron plugin provides these env vars for the preload path.
      preload: path.resolve(
        currentDir,
        path.join(process.env.QUASAR_ELECTRON_PRELOAD_FOLDER,
        'electron-preload' + process.env.QUASAR_ELECTRON_PRELOAD_EXTENSION)
      )
    }    
  });
  // In dev, Quasar serves your app on a dev server; in prod, load local file.
  if (process.env.DEV) {
    console.log('[main] loading DEV url:', process.env.APP_URL)
    await mainWindow.loadURL(process.env.APP_URL)
  } else {
    console.log('[main] loading PROD index.html')
    await mainWindow.loadFile('index.html')
  }
  // Cleanup reference when window is closed.
  mainWindow.on('closed', () => {
    console.log('[main] window closed')
    mainWindow = null
  });

  mainWindow.on('blur', () => {
    if (!mainWindow.webContents.isDevToolsOpened()) mainWindow.hide()
  });
  
  mainWindow.webContents.on('did-start-loading', () => {
    console.log('[main] renderer did-start-loading')
  });

  mainWindow.webContents.on('did-finish-load', () => {
    console.log('[main] renderer did-finish-load');
    mainWindow.webContents.openDevTools({ mode: 'detach' });
  });
}
// Position the popover under macOS toolbar and display.
function positionNearTrayAndShow () {
  if (!tray || !mainWindow) return

  const icon = tray.getBounds()
  const display = screen.getDisplayNearestPoint({ x: icon.x, y: icon.y }).bounds
  const [winW, winH] = mainWindow.getSize()
  const PADDING = 8

  // Ideal centered X under the tray icon
  const idealX = icon.x + icon.width / 2 - winW / 2

  // Clamp X so we stay fully on-screen
  const leftEdge  = display.x
  const rightEdge = display.x + display.width - winW
  const x = Math.round(Math.max(leftEdge, Math.min(idealX, rightEdge)))

  // Y depends on platform (menu bar vs taskbar)
  const y = platform === 'darwin'
    ? Math.round(icon.y + icon.height + PADDING)   // below menu bar
    : Math.round(icon.y - winH - PADDING)          // above taskbar

  mainWindow.setPosition(x, y, false)
  mainWindow.show()
  mainWindow.focus()
}

function togglePopover () {
  if (!mainWindow) return
  if (mainWindow.isVisible()) mainWindow.hide()
  else positionNearTrayAndShow()
}

//  --- App Lifecycle -----------------------------------------------
app.whenReady().then(() => {
  console.log('[main] app is ready');
  createWindow();
  console.log('[main] creating tray');

  // Create a tray icon.
  const trayPath = path.resolve(process.cwd(), 'src-electron/icons/trayTemplate.png');
  const trayImage = nativeImage.createFromPath(trayPath).resize({ width: 15, height: 15 });
  trayImage.setTemplateImage(true);
  tray = new Tray(trayImage); 
  tray.setTitle('⚡');                
  tray.setToolTip('Ankify');

  // Right-click context menu
  tray.setContextMenu(Menu.buildFromTemplate([
    { label: 'Toggle', click: () => togglePopover() },
    { label: 'Show/Hide', click: () => {
        if (!mainWindow) return
        if (mainWindow.isVisible()) { console.log('[main] hiding'); mainWindow.hide() }
        else { console.log('[main] showing'); mainWindow.show(); mainWindow.focus() }
      }},
    { type: 'separator' },
    { label: 'Quit', role: 'quit' }
  ]))
  tray.on('click', () => {
    console.log('[main] tray clicked')
    if (!mainWindow) return
    if (mainWindow.isVisible()) {
       mainWindow.hide();
      } else { 
        positionNearTrayAndShow();
      }
  })
  globalShortcut.register('CommandOrControl+Shift+F', () => togglePopover());

  // open DevTools detached for debugging
  if (process.env.DEBUGGING && mainWindow) mainWindow.webContents.openDevTools({ mode: 'detach' })
});

app.on('window-all-closed', () => {
  console.log('[main] all windows closed');
  if (platform !== 'darwin') {
    console.log('[main] quitting app');
    app.quit();
  }
});

app.on('activate', () => {
  console.log('[main] activate event');
  if (mainWindow === null) {
    createWindow();
  }
});
// --- IPC: window control endpoints -------------------------------------
ipcMain.handle('window:hide', () => {
  if (mainWindow && !mainWindow.isDestroyed()) mainWindow.hide();
});
ipcMain.handle('window:close', () => {
  if (mainWindow && !mainWindow.isDestroyed()) mainWindow.close();
});
// --- IPC: Jisho lookup -------------------------------------------------
// Renderer calls: await window.ankify.dictLookup(text)
ipcMain.handle('dict:lookup', async (_event, query) => {
  if (!query || typeof query !== 'string') return { ok: false, error: 'Empty query' };
  try {
    const url = `https://jisho.org/api/v1/search/words?keyword=${encodeURIComponent(query)}`
    const res = await fetch(url) 
    if (!res.ok) return { ok: false, error: `HTTP ${res.status}` }
    const json = await res.json()
    return { ok: true, data: json }
  } catch (err) {
    return { ok: false, error: String(err) }
  }
});
// --- IPC: AnkiConnect bridge ------------------------------------------------
// Renderer calls: await window.ankify.invokeAnki(action, params)
// We POST JSON to AnkiConnect on 127.0.0.1:8765 and return result/error.
ipcMain.handle('ankiconnect:invoke', async (_event, { action, params }) => {
  const payload = JSON.stringify({ action, version: 6, params });
  // Node’s http.request() is callback-based and stream-based — not Promise-based.
  // So you can’t just await http.request() directly.
  // That’s why we create a new Promise manually:
  const { status, body } = await new Promise((resolve, reject) => {
    const request = http.request(
      {
        host: '127.0.0.1',
        port: 8765,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': Buffer.byteLength(json) 
        }
      },
      // callback (response) => { … } runs once the remote server (AnkiConnect) sends back an HTTP response.
      // response object emits 'data' events as chunks of text arrive over the network & emits an 'end' event once all chunks are done and the connection is closed.
      (response) => {
        response.setEncoding('utf8'); 
        let raw = '';
        response.on('data', (chunk) => { raw += chunk; });
        response.on('end', () => resolve({ status: response.statusCode ?? 0, body: raw }));
      }
    );
    request.setTimeout(5000, () => {
      request.destroy(new Error('Request timed out'));
    });
    request.on('error', reject);
    request.write(payload);
    request.end();
  });
  if (status !== 200) {
    throw new Error(`AnkiConnect HTTP ${status}: ${body}`);
  }
  let parsed;
  try {
    parsed = JSON.parse(body || '{}');
  } catch (e) {
    throw new Error(`Invalid JSON from AnkiConnect: ${String(e)}`);
  }
  if (parsed.error) throw new Error(parsed.error);
  return parsed.result;
});

ipcMain.on('ankify:log', (_evt, args) => {
  console.log('[RENDERER]', ...args);
  log.info('[RENDERER]', ...args);
});
// --- IPC: kuromoji tokenization ------------------------------------------
// Renderer calls: await window.ankify.tokenize(text)
// We just build the tokenizer once, then tokenize each string.
ipcMain.handle('morph:tokenize', async (_e, text) => {
  const t = await getTokenizer();
  return t.tokenize(text || '');
});